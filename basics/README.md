#  Java Basics & Fundamentals

This module is designed to build a strong foundation in core Java concepts, including Input/Output using Scanner, Variables, Conditional Statements (if–else), and Loops (for / while). These fundamentals are essential before moving on to Data Structures and Algorithms.

---

##  Problem Set

### 1. Print Hello World
Problem: Print "Hello, World!" to the console.  
Approach: Use System.out.println() to display output.  
Complexity: Time — O(1) | Space — O(1)  
Key Learning: Basic Java program structure and console output.

---

### 2. Print Numbers from 1 to N
Problem: Given an integer N, print all numbers from 1 to N.  
Approach: Use a for loop that iterates from 1 to N.  
Complexity: Time — O(N) | Space — O(1)  
Key Learning: Loop control and iteration logic.

---

### 3. Sum of First N Natural Numbers
Problem: Find the sum of numbers from 1 to N.  
Approach: Use a loop to accumulate the sum or apply the formula N * (N + 1) / 2.  
Complexity: Time — O(N) (loop) | Space — O(1)  
Key Learning: Arithmetic operations and accumulator variables.

---

### 4. Even or Odd
Problem: Check whether a given number is even or odd.  
Approach: Use the modulo operator (%). If n % 2 == 0, the number is even.  
Complexity: Time — O(1) | Space — O(1)  
Key Learning: Using the remainder operator for condition checks.

---

### 5. Positive, Negative, or Zero
Problem: Determine whether a number is positive, negative, or zero.  
Approach: Use if–else if–else conditional statements.  
Complexity: Time — O(1) | Space — O(1)  
Key Learning: Multi-branch conditional logic.

---

### 6. Largest of Three Numbers
Problem: Find the largest number among three given integers.  
Approach: Use nested if–else conditions or logical AND operators.  
Complexity: Time — O(1) | Space — O(1)  
Key Learning: Logical comparisons and decision making.

---

### 7. Factorial of a Number
Problem: Compute the factorial of a number N (example: 5! = 120).  
Approach: Use an iterative loop to multiply values from 1 to N.  
Complexity: Time — O(N) | Space — O(1)  
Key Learning: Loop-based multiplication and mathematical reasoning.

---

### 8. Fibonacci Series (Iterative)
Problem: Print the first N terms of the Fibonacci sequence.  
Approach: Use variables to track the previous, current, and next values.  
Complexity: Time — O(N) | Space — O(1)  
Key Learning: Sequence generation and variable updates.

---

### 9. Reverse a Number
Problem: Reverse a given number (example: 123 → 321).  
Approach: Extract digits using % 10 and rebuild the number using multiplication.  
Complexity: Time — O(log N) | Space — O(1)  
Key Learning: Digit manipulation and number reconstruction.

---

### 10. Check Palindrome Number
Problem: Check if a number reads the same backward (example: 121).  
Approach: Reverse the number and compare it with the original.  
Complexity: Time — O(log N) | Space — O(1)  
Key Learning: Combining logic, loops, and comparisons.
